/* eslint-disable global-require */
/* eslint-disable guard-for-in */
/* eslint-disable import/no-import-module-exports */
const isErrorHandlerTriggered = require('../../../lib/middleware/isErrorHandlerTriggered');
const { render } = require('../../../lib/response/render');
const isDevelopmentMode = require('../../../lib/util/isDevelopmentMode');

module.exports = async (request, response, stack, next) => {
  /** Get all promise delegate */
  const promises = [];
  Object.keys(stack).forEach((id) => {
    // Check if middleware is async
    if (stack[id] instanceof Promise) {
      promises.push(stack[id]);
    }
  });

  try {
    /** Wait for all async middleware to be completed */
    await Promise.all(promises);

    /** If a rejected middleware called next(error) without throwing an error */
    if (response.locals.errorHandlerTriggered === true) {
      return;
    } else {
      const route = request.currentRoute
      // Check if this is a redirection or not.
      if (response.$redirectUrl) {
        response.redirect(response.statusCode || 302, response.$redirectUrl);
      } else if (route.isApi === true) { // Check if the request is an API.
        response.json(response.$body || {});
      } else {
        // eslint-disable-next-line max-len
        // Check if `$body` is empty or not. If yes, we consider the content is already generated by previous middlewares
        // eslint-disable-next-line no-lonely-if
        if (response.$body && response.$body !== '') {
          response.send(response.$body);
        } else {
          response.context.route = route;
          if (isDevelopmentMode() && request.query && request.query.fashRefresh === 'true') {
            response.json({
              success: true,
              eContext: response.context
            });
          } else {
            render(response, route);
          }
        }
      }
    }
  } catch (error) {
    if (!isErrorHandlerTriggered(response)) {
      next(error);
    } else {
      // Do nothing here since the next(error) is already called when the error is thrown on each middleware
    }
  }
};
